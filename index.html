<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Document Classifier</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #e5e7eb;
        }
        ::-webkit-scrollbar-thumb {
            background-color: #9ca3af;
            border-radius: 4px;
        }
        .message-box {
            position: fixed;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease-in-out;
            opacity: 0;
            visibility: hidden;
        }
        .message-box.show {
            opacity: 1;
            visibility: visible;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #pdf-canvas {
            touch-action: none;
            cursor: grab;
        }
        #pdf-viewer-container.no-pdf {
            background-color: #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #9ca3af;
            font-size: 1.5rem;
            font-weight: 500;
            user-select: none;
            cursor: default;
        }
        #current-page-input {
            width: 3rem;
            text-align: center;
            border: 1px solid #d1d5db;
            border-radius: 0.25rem;
            padding: 0.125rem 0.25rem;
            font-weight: 600;
            background: white;
        }
        #current-page-input:focus {
            outline: 2px solid #3b82f6;
            outline-offset: 1px;
            border-color: #3b82f6;
        }
        #current-page-input::-webkit-outer-spin-button,
        #current-page-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        #current-page-input {
            -moz-appearance: textfield;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="flex flex-col h-screen overflow-hidden">
        <!-- Header -->
        <header class="bg-white p-4 shadow-md flex flex-col sm:flex-row items-center justify-between space-y-2 sm:space-y-0">
            <div class="flex items-center">
                <h1 class="text-xl md:text-2xl font-bold text-gray-800">PDF Document Classifier</h1>
            </div>
            <div class="flex items-center space-x-2 sm:space-x-4">
                <div id="page-info" class="text-xs sm:text-sm md:text-base font-semibold text-gray-600">
                    Page: <input type="number" id="current-page-input" min="1" value="1" class="hidden" /> <span id="current-page-display">?</span> / <span id="total-pages-display">?</span>
                </div>
                <button id="export-button" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow hover:bg-blue-700 transition-colors duration-200 focus:outline-none text-sm">
                    Export All <span id="export-spinner" class="spinner hidden"></span>
                </button>
            </div>
        </header>

        <!-- Main Content Area -->
        <main class="flex-1 flex flex-col md:flex-row overflow-hidden">
            <!-- Left Sidebar for Instructions -->
            <aside class="w-full md:w-1/3 lg:w-1/4 p-4 bg-white md:border-r border-gray-200 shadow-inner overflow-y-auto flex flex-col order-1 md:order-1">
                <div class="flex-shrink-0">
                    <h2 class="text-lg font-bold mb-3">Instructions</h2>
                    <div class="text-sm text-gray-700 space-y-3">
                        <div class="bg-gray-50 p-2 rounded border border-gray-200">
                            <h3 class="font-bold mb-1">Navigation & Documents</h3>
                            <div class="text-xs space-y-1">
                                <div><kbd class="px-1 py-0.5 bg-gray-200 rounded font-mono text-xs">←</kbd><kbd class="px-1 py-0.5 bg-gray-200 rounded font-mono text-xs">→</kbd> Navigate pages</div>
                                <div><kbd class="px-1 py-0.5 bg-gray-200 rounded font-mono text-xs">N</kbd> New document starts</div>
                                <div><kbd class="px-1 py-0.5 bg-gray-200 rounded font-mono text-xs">L</kbd> Continue previous document</div>
                            </div>
                        </div>
                        <div class="bg-gray-50 p-2 rounded border border-gray-200">
                            <h3 class="font-bold mb-1">Actions</h3>
                            <div class="text-xs space-y-1">
                                <div><kbd class="px-1 py-0.5 bg-gray-200 rounded font-mono text-xs">Del</kbd> Mark page for deletion</div>
                                <div><kbd class="px-1 py-0.5 bg-gray-200 rounded font-mono text-xs">T</kbd> Rotate page 90°</div>
                                <div><kbd class="px-1 py-0.5 bg-gray-200 rounded font-mono text-xs">C</kbd> Clear all tags</div>
                                <div><kbd class="px-1 py-0.5 bg-gray-200 rounded font-mono text-xs">Z</kbd> Reset zoom/pan</div>
                            </div>
                        </div>
                        <div class="bg-slate-50 p-3 rounded border border-slate-200">
                            <h3 class="font-bold mb-2 text-slate-800">Content Tagging</h3>
                            <div class="space-y-2">
                                <div class="bg-blue-50 p-2 rounded border border-blue-200">
                                    <h4 class="font-semibold mb-1 text-blue-800 text-xs">Hebrew Content</h4>
                                    <div class="text-xs space-y-1">
                                        <div><kbd class="px-1 py-0.5 bg-blue-200 rounded font-mono text-xs">H</kbd> Hebrew printed</div>
                                        <div><kbd class="px-1 py-0.5 bg-blue-200 rounded font-mono text-xs">P</kbd> Hebrew paper clippings</div>
                                        <div><kbd class="px-1 py-0.5 bg-blue-200 rounded font-mono text-xs">W</kbd> Hebrew handwritten</div>
                                    </div>
                                </div>
                                <div class="bg-green-50 p-2 rounded border border-green-200">
                                    <h4 class="font-semibold mb-1 text-green-800 text-xs">Non-Hebrew Languages</h4>
                                    <div class="text-xs space-y-1">
                                        <div><kbd class="px-1 py-0.5 bg-green-200 rounded font-mono text-xs">F</kbd> Non-Hebrew printed</div>
                                        <div><kbd class="px-1 py-0.5 bg-green-200 rounded font-mono text-xs">G</kbd> Non-Hebrew paper clippings</div>
                                    </div>
                                </div>
                                <div class="bg-purple-50 p-2 rounded border border-purple-200">
                                    <h4 class="font-semibold mb-1 text-purple-800 text-xs">Other Content</h4>
                                    <div class="text-xs space-y-1">
                                        <div><kbd class="px-1 py-0.5 bg-purple-200 rounded font-mono text-xs">I</kbd> Image</div>
                                        <div><kbd class="px-1 py-0.5 bg-purple-200 rounded font-mono text-xs">U</kbd> Undefined</div>
                                        <div><kbd class="px-1 py-0.5 bg-purple-200 rounded font-mono text-xs">M</kbd> Mixed (Hebrew and Non-Hebrew)</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </aside>

            <!-- PDF Viewer (Center) -->
            <div class="flex-1 p-2 sm:p-4 flex flex-col items-center overflow-hidden relative order-2 md:order-2">
                <div id="pdf-viewer-container" class="relative w-full h-full flex items-center justify-center overflow-auto rounded-xl bg-gray-200 shadow-inner no-pdf">
                    <canvas id="pdf-canvas" class="bg-white shadow-xl rounded-lg max-w-full h-auto"></canvas>
                    <div id="loading-indicator" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-lg text-gray-500 font-medium hidden">Loading PDF...</div>
                    <div id="empty-message" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">
                        Please select a PDF file to begin.
                    </div>
                </div>
                <div class="mt-2 sm:mt-4 text-center">
                    <span id="current-page-tag" class="text-sm sm:text-base font-bold text-blue-600">No tag assigned</span>
                </div>
            </div>

            <!-- Right Sidebar for controls and history -->
            <aside class="w-full md:w-1/3 lg:w-1/4 p-4 bg-white md:border-l border-gray-200 shadow-inner overflow-y-auto flex flex-col order-3 md:order-3">
                <div id="file-input-section" class="mb-4 pb-4 border-b border-gray-200">
                    <h2 class="text-lg font-bold mb-2">Load PDF</h2>
                    <p class="text-sm text-gray-600 mb-2">Select a PDF file to begin.</p>
                    <input type="file" id="pdf-file-input" accept=".pdf" class="w-full p-2 border border-gray-300 rounded-lg text-sm">
                </div>
                
                <div id="tag-input-section" class="mb-4 pb-4 border-b border-gray-200">
                    <h2 class="text-lg font-bold mb-2">Load Tags</h2>
                    <p class="text-sm text-gray-600 mb-2">Select a JSON file to restore saved tags.</p>
                    <input type="file" id="tags-file-input" accept=".json" class="w-full p-2 border border-gray-300 rounded-lg text-sm">
                </div>

                <div class="mt-4 flex-grow flex flex-col">
                    <h2 class="text-lg font-bold mb-2">Page History</h2>
                    <div id="tag-history" class="text-sm text-gray-700 space-y-2 flex-grow overflow-y-auto max-h-96 pr-2">
                        <!-- Tag history will be populated here -->
                    </div>
                </div>
            </aside>
        </main>
    </div>

    <!-- Custom Message Box -->
    <div id="message-box" class="message-box bg-red-500 text-white"></div>

    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    
    <script>
        // Initialize PDF.js worker immediately
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // Configuration
        const CONFIG = {
            LOCAL_STORAGE_KEY: 'pdfTaggerTags',
            SCALE_FACTOR: 1.1,
            CONTENT_TAGS: [
                'hebrew printed', 'hebrew paper clippings', 'hebrew handwritten',
                'non-hebrew printed', 'non-hebrew paper clippings',
                'image', 'undefined', 'mixed'
            ]
        };

        // Application State
        const state = {
            pdfDoc: null,
            pdfBytes: null,
            currentPage: 1,
            pageTags: {},
            lastManualTag: null,
            pdfFilename: 'pdf_classifications',
            currentScale: 1.0,
            isDragging: false,
            lastX: 0,
            lastY: 0,
            translateX: 0,
            translateY: 0,
            activeRenderTask: null
        };

        // DOM Elements
        const elements = {
            canvas: document.getElementById('pdf-canvas'),
            currentPageDisplay: document.getElementById('current-page-display'),
            currentPageInput: document.getElementById('current-page-input'),
            totalPagesDisplay: document.getElementById('total-pages-display'),
            currentPageTagDisplay: document.getElementById('current-page-tag'),
            tagHistoryContainer: document.getElementById('tag-history'),
            loadingIndicator: document.getElementById('loading-indicator'),
            pdfFileInput: document.getElementById('pdf-file-input'),
            tagsFileInput: document.getElementById('tags-file-input'),
            exportButton: document.getElementById('export-button'),
            messageBox: document.getElementById('message-box'),
            pdfViewerContainer: document.getElementById('pdf-viewer-container'),
            emptyMessage: document.getElementById('empty-message')
        };

        const ctx = elements.canvas.getContext('2d');

        // Utility Functions
        function showMessage(message, type = 'error') {
            elements.messageBox.textContent = message;
            elements.messageBox.className = `message-box show ${type === 'error' ? 'bg-red-500' : 'bg-green-500'} text-white`;
            setTimeout(() => {
                elements.messageBox.classList.remove('show');
            }, 1000);
        }

        function saveTagsToLocalStorage() {
            try {
                localStorage.setItem(CONFIG.LOCAL_STORAGE_KEY, JSON.stringify(state.pageTags));
            } catch (e) {
                console.error('Error saving to local storage:', e);
                showMessage('Could not save progress. Browser storage limit reached.');
            }
        }

        function initializePageTags(pageNum) {
            if (!state.pageTags[pageNum]) {
                state.pageTags[pageNum] = {
                    tags: [],
                    rotation: 0
                };
            }
        }

        // PDF Rendering Functions
        async function renderPage(pageNum) {
            if (state.pdfDoc === null) return;
            
            // First, cancel any active render task and wait for it to complete
            if (state.activeRenderTask) {
                try {
                    console.log('Cancelling previous render task...');
                    state.activeRenderTask.cancel();
                    await state.activeRenderTask.promise.catch(() => {
                        console.log('Previous render cancelled successfully');
                    });
                } catch (e) {
                    console.log('Render cancellation completed');
                }
                state.activeRenderTask = null;
            }
            
            await new Promise(resolve => setTimeout(resolve, 10));
            
            elements.loadingIndicator.style.display = 'block';

            try {
                if (pageNum < 1 || pageNum > state.pdfDoc.numPages) {
                    showMessage('Invalid page number.', 'error');
                    return;
                }
                
                console.log(`Starting render for page ${pageNum}`);
                
                state.currentPage = pageNum;
                initializePageTags(state.currentPage);
                const rotation = state.pageTags[state.currentPage].rotation;
                const page = await state.pdfDoc.getPage(state.currentPage);
                
                const naturalViewport = page.getViewport({ scale: 1, rotation });
                console.log(`Page ${pageNum} natural size: ${naturalViewport.width}x${naturalViewport.height}, rotation: ${rotation}`);
                
                const containerWidth = elements.pdfViewerContainer.clientWidth - 20;
                const containerHeight = elements.pdfViewerContainer.clientHeight - 20;
                console.log(`Container size: ${containerWidth}x${containerHeight}`);
                
                const scaleX = containerWidth / naturalViewport.width;
                const scaleY = containerHeight / naturalViewport.height;
                const fitScale = Math.min(scaleX, scaleY, 1.5) * 0.9;
                
                console.log(`Calculated scales - X: ${scaleX}, Y: ${scaleY}, fit: ${fitScale}`);
                
                const isPageJump = Math.abs(pageNum - (state.previousPage || 1)) > 1;
                if (isPageJump || state.currentScale === 1.0) {
                    state.currentScale = fitScale;
                    state.translateX = 0;
                    state.translateY = 0;
                    console.log(`Reset scale to: ${state.currentScale}`);
                }
                
                state.previousPage = pageNum;
                
                const viewport = page.getViewport({ scale: state.currentScale, rotation });
                console.log(`Final viewport: ${viewport.width}x${viewport.height} at scale ${state.currentScale}`);
                
                const canvas = elements.canvas;
                
                canvas.width = 1;
                canvas.height = 1;
                
                const ctx = canvas.getContext('2d');
                
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                
                ctx.clearRect(0, 0, viewport.width, viewport.height);
                
                console.log(`Canvas reset and sized to: ${canvas.width}x${canvas.height}`);
                
                state.activeRenderTask = page.render({
                    canvasContext: ctx,
                    viewport: viewport
                });
                
                await state.activeRenderTask.promise;
                
                state.activeRenderTask = null;
                
                canvas.style.transform = `translate(${state.translateX}px, ${state.translateY}px)`;
                
                updatePageDisplay();
                console.log(`Successfully rendered page ${pageNum}`);

            } catch (error) {
                state.activeRenderTask = null;
                
                console.error('Render error details:', error);
                
                if (error.name === 'RenderingCancelledException' || 
                    error.message?.includes('cancelled') ||
                    error.message?.includes('Worker was destroyed')) {
                    console.log('Render cancelled (expected behavior)');
                    return;
                }
                
                showMessage(`Failed to render page ${pageNum}: ${error.message}`);
            } finally {
                elements.loadingIndicator.style.display = 'none';
            }
        }

        function updatePageDisplay() {
            console.log('updatePageDisplay called for page:', state.currentPage);
            console.log('Page tags:', state.pageTags[state.currentPage]?.tags);
            console.log('Page rotation:', state.pageTags[state.currentPage]?.rotation);
            
            elements.currentPageInput.value = state.currentPage;
            const currentTags = state.pageTags[state.currentPage].tags;
            const rotation = state.pageTags[state.currentPage].rotation;
            const rotationTag = rotation === 0 ? '' : ` (Rotated ${rotation}°)`;
            
            const displayText = (currentTags.length > 0)
                ? currentTags.join(', ') + rotationTag
                : 'No tag assigned' + rotationTag;
                
            console.log('Setting page display text to:', displayText);
            elements.currentPageTagDisplay.textContent = displayText;
        }

        // PDF Loading Functions
        async function loadPDF(source) {
            console.log('Loading PDF...', source instanceof File ? source.name : source);
            
            elements.loadingIndicator.style.display = 'block';
            elements.emptyMessage.style.display = 'none';
            elements.pdfViewerContainer.classList.remove('no-pdf');
            
            state.currentPage = 1;
            state.lastManualTag = null;
            state.pageTags = {};
            state.currentScale = 1.0;
            state.translateX = 0;
            state.translateY = 0;
            
            elements.tagHistoryContainer.innerHTML = '';
            elements.currentPageTagDisplay.textContent = 'No tag assigned';

            localStorage.removeItem(CONFIG.LOCAL_STORAGE_KEY);
            console.log('Cleared localStorage and reset all state');

            try {
                let pdfData;
                if (source instanceof File) {
                    console.log('Reading file as array buffer...');
                    pdfData = await source.arrayBuffer();
                    console.log('File read successfully, size:', pdfData.byteLength);
                } else {
                    throw new Error("Invalid file type.");
                }

                state.pdfBytes = pdfData;
                console.log('Loading PDF document...');
                state.pdfDoc = await pdfjsLib.getDocument({ data: pdfData }).promise;
                console.log('PDF loaded successfully, pages:', state.pdfDoc.numPages);
                
                elements.totalPagesDisplay.textContent = state.pdfDoc.numPages;
                elements.currentPageInput.setAttribute('max', state.pdfDoc.numPages);
                
                elements.currentPageDisplay.style.display = 'none';
                elements.currentPageInput.classList.remove('hidden');

                await renderPage(state.currentPage);
                console.log('First page rendered');
                
            } catch (error) {
                console.error('Error loading PDF:', error);
                showMessage('Failed to load PDF: ' + error.message);
                elements.emptyMessage.style.display = 'block';
                elements.pdfViewerContainer.classList.add('no-pdf');
                
                elements.currentPageInput.classList.add('hidden');
                elements.currentPageDisplay.style.display = 'inline';
            } finally {
                elements.loadingIndicator.style.display = 'none';
            }
        }

        // Tagging Functions
        function updateTag(tag, isCarrying) {
            initializePageTags(state.currentPage);
            
            if (CONFIG.CONTENT_TAGS.includes(tag)) {
                state.pageTags[state.currentPage].tags = state.pageTags[state.currentPage].tags.filter(
                    existingTag => !CONFIG.CONTENT_TAGS.includes(existingTag)
                );
            }

            if (!state.pageTags[state.currentPage].tags.includes(tag)) {
                state.pageTags[state.currentPage].tags.push(tag);
            }
            
            if (isCarrying) {
                state.lastManualTag = tag;
            } else {
                if (tag !== 'delete') {
                    state.lastManualTag = null;
                }
            }
            
            saveTagsToLocalStorage();
            updateTagHistory();
            renderPage(state.currentPage);
        }

        function updateTagHistory() {
            console.log('updateTagHistory called');
            console.log('Current pageTags state:', state.pageTags);
            
            elements.tagHistoryContainer.innerHTML = '';
            
            // Get all pages that have been initialized (tagged or at least visited)
            // Sort in descending order (highest page numbers first)
            const allPages = Object.keys(state.pageTags).map(Number).sort((a, b) => b - a);

            console.log('History pages order:', allPages);

            allPages.forEach(page => {
                const tags = state.pageTags[page].tags;
                const rotation = state.pageTags[page].rotation;
                const rotationText = rotation === 0 ? '' : ` (Rotated ${rotation}°)`;
                
                let displayText = '';
                if (tags.length === 0) {
                    displayText = '';
                } else {
                    displayText = tags.join(', ');
                }
                
                console.log(`Page ${page} history display:`, displayText);
                
                const historyItem = document.createElement('div');
                historyItem.className = 'flex justify-between items-center bg-gray-100 p-2 rounded-lg';
                historyItem.innerHTML = `<span class="text-xs font-medium text-gray-600">Page ${page}:</span> <span class="text-xs text-blue-600 font-medium truncate ml-2">${displayText}${rotationText}</span>`;
                elements.tagHistoryContainer.appendChild(historyItem);
            });
        }

        // Export Functions
        async function exportRotatedAndCleanPdf() {
            if (!state.pdfBytes) {
                showMessage('No PDF loaded to export.');
                return;
            }

            try {
                const { PDFDocument, degrees } = window.PDFLib;
                if (!PDFDocument) {
                    throw new Error('PDF-lib library not loaded.');
                }
                
                const originalPdf = await PDFDocument.load(state.pdfBytes);
                const newPdf = await PDFDocument.create();

                for (let i = 0; i < originalPdf.getPageCount(); i++) {
                    const pageNum = i + 1;
                    initializePageTags(pageNum);

                    if (state.pageTags[pageNum].tags.includes('delete')) {
                        continue;
                    }

                    const [page] = await newPdf.copyPages(originalPdf, [i]);
                    const rotation = state.pageTags[pageNum].rotation;
                    
                    if (rotation !== 0) {
                        page.setRotation(degrees(rotation));
                    }
                    
                    newPdf.addPage(page);
                }

                const modifiedPdfBytes = await newPdf.save();
                const blob = new Blob([modifiedPdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                
                const pdfAnchor = document.createElement('a');
                pdfAnchor.href = url;
                pdfAnchor.download = `${state.pdfFilename}_clean.pdf`;
                document.body.appendChild(pdfAnchor);
                pdfAnchor.click();
                document.body.removeChild(pdfAnchor);
                
            } catch (error) {
                console.error('Error exporting PDF:', error);
                throw new Error('Failed to export PDF.');
            }
        }

        function exportCleanTagsJson() {
            if (Object.keys(state.pageTags).length === 0) {
                showMessage('No pages have been tagged yet.');
                return;
            }

            const cleanTags = {};
            let newPageNumber = 1;
            
            for (let i = 1; i <= state.pdfDoc.numPages; i++) {
                const pageData = state.pageTags[i];
                if (pageData && !pageData.tags.includes('delete')) {
                    cleanTags[newPageNumber] = {
                        tags: [...pageData.tags],
                        rotation: pageData.rotation
                    };
                    newPageNumber++;
                }
            }

            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(cleanTags, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", `${state.pdfFilename}_clean.json`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        async function handleCombinedExport() {
            elements.exportButton.disabled = true;
            elements.exportButton.classList.add('bg-blue-400');
            elements.exportButton.innerHTML = 'Exporting... <span class="spinner"></span>';

            try {
                exportCleanTagsJson();
                await exportRotatedAndCleanPdf();
                showMessage('Export complete. Both PDF and tags JSON have been downloaded.', 'success');
            } catch (error) {
                console.error('Combined export failed:', error);
                showMessage('Export failed. Please try again.', 'error');
            } finally {
                elements.exportButton.disabled = false;
                elements.exportButton.classList.remove('bg-blue-400');
                elements.exportButton.innerHTML = 'Export All <span class="spinner hidden"></span>';
            }
        }

        function handleKeydown(e) {
            if (state.pdfDoc === null) return;

            const key = e.key.toLowerCase();
            
            switch (key) {
                case 'arrowleft':
                    if (state.currentPage > 1) {
                        state.currentPage--;
                        renderPage(state.currentPage);
                    }
                    break;
                    
                case 'arrowright':
                    console.log('Arrow right pressed, currentPage:', state.currentPage, 'lastManualTag:', state.lastManualTag);
                    if (state.currentPage < state.pdfDoc.numPages) {
                        state.currentPage++;
                        console.log('Moved to page:', state.currentPage);
                        if (state.lastManualTag && (!state.pageTags[state.currentPage] || state.pageTags[state.currentPage].tags.length === 0)) {
                            console.log('Auto-applying tag:', state.lastManualTag, 'to page:', state.currentPage);
                            initializePageTags(state.currentPage);
                            state.pageTags[state.currentPage].tags.push(state.lastManualTag);
                            saveTagsToLocalStorage();
                            updateTagHistory();
                        } else {
                            console.log('Not auto-tagging because:');
                            console.log('  - lastManualTag:', state.lastManualTag);
                            console.log('  - existing tags on page:', state.pageTags[state.currentPage]?.tags || 'none');
                        }
                        renderPage(state.currentPage);
                    }
                    break;
                    
                case 'h': 
                    updateTag('hebrew printed', true); 
                    break;
                case 'p': 
                    updateTag('hebrew paper clippings', true); 
                    break;
                case 'w': 
                    updateTag('hebrew handwritten', true); 
                    break;
                case 'f': 
                    updateTag('non-hebrew printed', true); 
                    break;
                case 'g': 
                    updateTag('non-hebrew paper clippings', true); 
                    break;
                case 'i': 
                    updateTag('image', true); 
                    break;
                case 'u': 
                    updateTag('undefined', true); 
                    break;
                case 'm': 
                    updateTag('mixed', true); 
                    break;
                
                case 'n':
                    initializePageTags(state.currentPage);
                    state.pageTags[state.currentPage].tags = ['new document starts', 'hebrew printed'];
                    state.lastManualTag = 'hebrew printed';
                    saveTagsToLocalStorage();
                    updateTagHistory();
                    renderPage(state.currentPage);
                    break;

                case 'delete':
                case 'backspace':
                    initializePageTags(state.currentPage);
                    state.pageTags[state.currentPage].tags = ['delete'];
                    saveTagsToLocalStorage();
                    updateTagHistory();
                    renderPage(state.currentPage);
                    showMessage('Page ' + state.currentPage +' marked for deletion.', 'success');
                    break;
                    
                case 't':
                    initializePageTags(state.currentPage);
                    state.pageTags[state.currentPage].rotation = (state.pageTags[state.currentPage].rotation + 90) % 360;
                    saveTagsToLocalStorage();
                    updateTagHistory();
                    renderPage(state.currentPage);
                    break;
                    
                case 'c':
                    state.pageTags[state.currentPage].tags = [];
                    state.lastManualTag = null;
                    saveTagsToLocalStorage();
                    updateTagHistory();
                    renderPage(state.currentPage);
                    showMessage('Tags cleared', 'success');
                    break;
                    
                case 'l':
                    if (state.currentPage > 1 && state.pageTags[state.currentPage]) {
                        const newDocTagIndex = state.pageTags[state.currentPage].tags.indexOf('new document starts');
                        if (newDocTagIndex !== -1) {
                            state.pageTags[state.currentPage].tags.splice(newDocTagIndex, 1);
                        }
                        const prevPageTags = state.pageTags[state.currentPage - 1];
                        if (prevPageTags && prevPageTags.tags.length > 0) {
                            state.lastManualTag = prevPageTags.tags[prevPageTags.tags.length - 1];
                        } else {
                            state.lastManualTag = null;
                        }
                        saveTagsToLocalStorage();
                        renderPage(state.currentPage);
                        showMessage('Continuing previous document.', 'success');
                    } else {
                        showMessage('Cannot continue previous document. No tags on previous page or this is the first page.', 'error');
                    }
                    break;
                    
                case 'z':
                    // Reset zoom and pan
                    const containerWidth = elements.pdfViewerContainer.clientWidth - 20;
                    const containerHeight = elements.pdfViewerContainer.clientHeight - 20;
                    if (state.pdfDoc && state.currentPage >= 1 && state.currentPage <= state.pdfDoc.numPages) {
                        // Recalculate the fit scale
                        initializePageTags(state.currentPage);
                        const rotation = state.pageTags[state.currentPage].rotation;
                        state.pdfDoc.getPage(state.currentPage).then(page => {
                            const naturalViewport = page.getViewport({ scale: 1, rotation });
                            const scaleX = containerWidth / naturalViewport.width;
                            const scaleY = containerHeight / naturalViewport.height;
                            const fitScale = Math.min(scaleX, scaleY, 1.5) * 0.9;
                            
                            state.currentScale = fitScale;
                            state.translateX = 0;
                            state.translateY = 0;
                            renderPage(state.currentPage);
                            showMessage('Zoom and pan reset to fit page.', 'success');
                        });
                    }
                    break;
            }
        }

        function handlePageInput(e) {
            if (e.key === 'Enter' || e.type === 'change') {
                const pageNum = parseInt(elements.currentPageInput.value, 10);
                if (state.pdfDoc && pageNum >= 1 && pageNum <= state.pdfDoc.numPages) {
                    renderPage(pageNum);
                } else {
                    elements.currentPageInput.value = state.currentPage;
                    showMessage('Please enter a valid page number.', 'error');
                }
            }
        }

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (file) {
                console.log('File selected:', file.name);
                state.pdfFilename = file.name.replace(/\.pdf$/, '');
                loadPDF(file);
            }
        }

        function handleTagsLoad(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const loadedTags = JSON.parse(e.target.result);
                        
                        for (const page in loadedTags) {
                            if (Array.isArray(loadedTags[page])) {
                                // Convert old format to new format
                                loadedTags[page] = { tags: loadedTags[page], rotation: 0 };
                            } else if (typeof loadedTags[page] !== 'object' || !Array.isArray(loadedTags[page].tags)) {
                                console.warn('Invalid page data format, skipping:', loadedTags[page]);
                                delete loadedTags[page];
                                continue;
                            }
                        }
                        
                        state.pageTags = loadedTags;
                        updateTagHistory();
                        renderPage(state.currentPage);
                        showMessage('Tags loaded successfully from file!', 'success');
                    } catch (error) {
                        console.error('Error parsing JSON file:', error);
                        showMessage('Failed to load tags. Invalid JSON format.', 'error');
                    }
                };
                reader.readAsText(file);
            }
        }

        // Canvas Interaction Handlers
        function handleMouseDown(e) {
            e.preventDefault();
            if (!state.pdfDoc) return;
            state.isDragging = true;
            state.lastX = e.clientX;
            state.lastY = e.clientY;
            elements.canvas.style.cursor = 'grabbing';
        }

        function handleMouseMove(e) {
            if (!state.isDragging || !state.pdfDoc) return;
            const dx = e.clientX - state.lastX;
            const dy = e.clientY - state.lastY;
            state.translateX += dx;
            state.translateY += dy;
            
            // Clamp translation to prevent dragging too far away
            const containerRect = elements.pdfViewerContainer.getBoundingClientRect();
            const maxTranslate = Math.max(containerRect.width, containerRect.height);
            state.translateX = Math.max(-maxTranslate, Math.min(maxTranslate, state.translateX));
            state.translateY = Math.max(-maxTranslate, Math.min(maxTranslate, state.translateY));
            
            elements.canvas.style.transform = `translate(${state.translateX}px, ${state.translateY}px)`;
            state.lastX = e.clientX;
            state.lastY = e.clientY;
        }

        function handleMouseUp() {
            state.isDragging = false;
            elements.canvas.style.cursor = 'grab';
        }

        function handleWheel(e) {
            e.preventDefault();
            if (!state.pdfDoc) return;
            
            const oldScale = state.currentScale;
            const zoomFactor = e.deltaY > 0 ? 1 / CONFIG.SCALE_FACTOR : CONFIG.SCALE_FACTOR;
            const newScale = oldScale * zoomFactor;
            
            // Ensure scale stays within reasonable bounds
            state.currentScale = Math.max(0.1, Math.min(5.0, newScale));
            
            // If scale didn't change (at limits), don't do anything
            if (state.currentScale === oldScale) {
                return;
            }

            // Get mouse position relative to the viewport container, not the canvas
            const containerRect = elements.pdfViewerContainer.getBoundingClientRect();
            const mouseX = e.clientX - containerRect.left;
            const mouseY = e.clientY - containerRect.top;

            const scaleFactor = state.currentScale / oldScale;

            // Adjust translation to zoom towards mouse position
            state.translateX = mouseX - scaleFactor * (mouseX - state.translateX);
            state.translateY = mouseY - scaleFactor * (mouseY - state.translateY);
            
            // Clamp translation to prevent the canvas from being dragged too far away
            const maxTranslate = Math.max(containerRect.width, containerRect.height);
            state.translateX = Math.max(-maxTranslate, Math.min(maxTranslate, state.translateX));
            state.translateY = Math.max(-maxTranslate, Math.min(maxTranslate, state.translateY));
            
            renderPage(state.currentPage);
        }

        // Event Listener Registration
        function initializeEventListeners() {
            document.addEventListener('keydown', handleKeydown);
            elements.currentPageInput.addEventListener('keydown', handlePageInput);
            elements.currentPageInput.addEventListener('change', handlePageInput);
            elements.pdfFileInput.addEventListener('change', handleFileLoad);
            elements.tagsFileInput.addEventListener('change', handleTagsLoad);
            elements.exportButton.addEventListener('click', handleCombinedExport);
            
            elements.canvas.addEventListener('mousedown', handleMouseDown);
            elements.canvas.addEventListener('mousemove', handleMouseMove);
            elements.canvas.addEventListener('mouseup', handleMouseUp);
            elements.canvas.addEventListener('mouseleave', handleMouseUp);
            elements.canvas.addEventListener('wheel', handleWheel);
        }

        // Application Initialization
        function initializeApp() {
            initializeEventListeners();
            console.log('PDF Document Classifier initialized successfully');
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeApp);
        } else {
            initializeApp();
        }
    </script>
</body>
</html>
