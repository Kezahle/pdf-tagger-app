<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Document Classifier</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* =============================================================================
           CUSTOM STYLES
           ============================================================================= */
        
        /* Base styles */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Custom scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #e5e7eb;
        }

        ::-webkit-scrollbar-thumb {
            background-color: #9ca3af;
            border-radius: 4px;
        }

        /* Message box styles */
        .message-box {
            position: fixed;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease-in-out;
            opacity: 0;
            visibility: hidden;
        }

        .message-box.show {
            opacity: 1;
            visibility: visible;
        }

        /* Loading spinner animation */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* PDF canvas styles */
        #pdf-canvas {
            touch-action: none;
            cursor: grab;
        }

        /* PDF viewer container when no PDF is loaded */
        #pdf-viewer-container.no-pdf {
            background-color: #f3f4f6;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: #9ca3af;
            font-size: 1.5rem;
            font-weight: 500;
            user-select: none;
            cursor: default;
        }

        /* Responsive design adjustments */
        @media (max-width: 768px) {
            .message-box {
                top: 1rem;
                left: 1rem;
                right: 1rem;
                transform: none;
                width: auto;
            }
        }

        /* Keyboard shortcut styling */
        kbd {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            line-height: 1;
            white-space: nowrap;
        }

        /* Focus states for accessibility */
        button:focus-visible,
        input:focus-visible {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }

        /* Custom button states */
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Smooth transitions */
        .transition-colors {
            transition-property: color, background-color, border-color;
            transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
            transition-duration: 150ms;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="flex flex-col h-screen overflow-hidden">
        <!-- Header -->
        <header class="bg-white p-4 shadow-md flex flex-col sm:flex-row items-center justify-between space-y-2 sm:space-y-0">
            <div class="flex items-center">
                <h1 class="text-xl md:text-2xl font-bold text-gray-800">PDF Document Classifier</h1>
            </div>
            <div class="flex items-center space-x-2 sm:space-x-4">
                <div id="page-info" class="text-xs sm:text-sm md:text-base font-semibold text-gray-600">
                    Page: <span id="current-page-display">?</span> / <span id="total-pages-display">?</span>
                </div>
                <button id="export-button" class="bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow hover:bg-blue-700 transition-colors duration-200 focus:outline-none text-sm">
                    Export All <span id="export-spinner" class="spinner hidden"></span>
                </button>
            </div>
        </header>

        <!-- Main Content Area -->
        <main class="flex-1 flex flex-col md:flex-row overflow-hidden">
            <!-- Left Sidebar for Instructions -->
            <aside class="w-full md:w-1/3 lg:w-1/4 p-4 bg-white md:border-r border-gray-200 shadow-inner overflow-y-auto flex flex-col order-1 md:order-1">
                <div class="flex-shrink-0">
                    <h2 class="text-lg font-bold mb-2">Instructions</h2>
                    <div class="text-sm text-gray-700 space-y-4">
                        <div class="bg-gray-50 p-3 rounded-lg border border-gray-200">
                            <h3 class="font-bold mb-2">Page Navigation</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li>Use <kbd class="px-2 py-1 bg-gray-200 rounded-md font-mono text-xs">←</kbd> and <kbd class="px-2 py-1 bg-gray-200 rounded-md font-mono text-xs">→</kbd> to navigate pages.</li>
                            </ul>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg border border-gray-200">
                            <h3 class="font-bold mb-2">Document Tagging</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><kbd class="px-2 py-1 bg-gray-200 rounded-md font-mono text-xs">N</kbd>: New document starts</li>
                                <li><kbd class="px-2 py-1 bg-gray-200 rounded-md font-mono text-xs">L</kbd>: Continue previous document</li>
                            </ul>
                        </div>
                        <div class="bg-blue-50 p-3 rounded-lg border border-blue-200">
                            <h3 class="font-bold mb-2 text-blue-800">Hebrew Content</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><kbd class="px-2 py-1 bg-blue-200 rounded-md font-mono text-xs">1</kbd>: Hebrew printed</li>
                                <li><kbd class="px-2 py-1 bg-blue-200 rounded-md font-mono text-xs">2</kbd>: Hebrew paper clippings</li>
                                <li><kbd class="px-2 py-1 bg-blue-200 rounded-md font-mono text-xs">3</kbd>: Hebrew handwritten</li>
                            </ul>
                        </div>
                        <div class="bg-green-50 p-3 rounded-lg border border-green-200">
                            <h3 class="font-bold mb-2 text-green-800">Non-Hebrew Languages</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><kbd class="px-2 py-1 bg-green-200 rounded-md font-mono text-xs">4</kbd>: Non-Hebrew printed</li>
                                <li><kbd class="px-2 py-1 bg-green-200 rounded-md font-mono text-xs">5</kbd>: Non-Hebrew paper clippings</li>
                            </ul>
                        </div>
                        <div class="bg-purple-50 p-3 rounded-lg border border-purple-200">
                            <h3 class="font-bold mb-2 text-purple-800">Other Content</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><kbd class="px-2 py-1 bg-purple-200 rounded-md font-mono text-xs">6</kbd>: Image</li>
                                <li><kbd class="px-2 py-1 bg-purple-200 rounded-md font-mono text-xs">7</kbd>: Undefined</li>
                                <li><kbd class="px-2 py-1 bg-purple-200 rounded-md font-mono text-xs">8</kbd>: Mixed (Hebrew and Non-Hebrew)</li>
                            </ul>
                        </div>
                        <div class="bg-gray-50 p-3 rounded-lg border border-gray-200">
                            <h3 class="font-bold mb-2">Special Tags & Actions</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><kbd class="px-2 py-1 bg-gray-200 rounded-md font-mono text-xs">R</kbd>: Redundant page</li>
                                <li><kbd class="px-2 py-1 bg-gray-200 rounded-md font-mono text-xs">T</kbd>: Rotate page 90 degrees</li>
                                <li><kbd class="px-2 py-1 bg-gray-200 rounded-md font-mono text-xs">C</kbd>: Clear all tags</li>
                            </ul>
                        </div>
                        <div id="page-jump-section" class="bg-gray-50 p-3 rounded-lg border border-gray-200">
                            <h3 class="font-bold mb-2">Go to Page</h3>
                            <p class="text-sm text-gray-600 mb-2">Enter a page number and press enter.</p>
                            <input type="number" id="page-jump-input" min="1" class="w-full p-2 border border-gray-300 rounded-lg text-center text-sm" placeholder="Page #">
                        </div>
                    </div>
                </div>
            </aside>

            <!-- PDF Viewer (Center) -->
            <div class="flex-1 p-2 sm:p-4 flex flex-col items-center overflow-hidden relative order-2 md:order-2">
                <div id="pdf-viewer-container" class="relative w-full h-full flex items-center justify-center overflow-auto rounded-xl bg-gray-200 shadow-inner no-pdf">
                    <canvas id="pdf-canvas" class="bg-white shadow-xl rounded-lg max-w-full h-auto"></canvas>
                    <div id="loading-indicator" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-lg text-gray-500 font-medium hidden">Loading PDF...</div>
                    <div id="empty-message" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">
                        Please select a PDF file to begin.
                    </div>
                </div>
                <div class="mt-2 sm:mt-4 text-center">
                    <span id="current-page-tag" class="text-sm sm:text-base font-bold text-blue-600">No tag assigned</span>
                </div>
            </div>

            <!-- Right Sidebar for controls and history -->
            <aside class="w-full md:w-1/3 lg:w-1/4 p-4 bg-white md:border-l border-gray-200 shadow-inner overflow-y-auto flex flex-col order-3 md:order-3">
                <div id="file-input-section" class="mb-4 pb-4 border-b border-gray-200">
                    <h2 class="text-lg font-bold mb-2">Load PDF</h2>
                    <p class="text-sm text-gray-600 mb-2">Select a PDF file to begin.</p>
                    <input type="file" id="pdf-file-input" accept=".pdf" class="w-full p-2 border border-gray-300 rounded-lg text-sm">
                </div>
                
                <div id="tag-input-section" class="mb-4 pb-4 border-b border-gray-200">
                    <h2 class="text-lg font-bold mb-2">Load Tags</h2>
                    <p class="text-sm text-gray-600 mb-2">Select a JSON file to restore saved tags.</p>
                    <input type="file" id="tags-file-input" accept=".json" class="w-full p-2 border border-gray-300 rounded-lg text-sm">
                </div>

                <div class="mt-4 flex-grow">
                    <h2 class="text-lg font-bold mb-2">Page History</h2>
                    <div id="tag-history" class="text-sm text-gray-700 space-y-2">
                        <!-- Tag history will be populated here -->
                    </div>
                </div>
            </aside>
        </main>
    </div>

    <!-- Custom Message Box -->
    <div id="message-box" class="message-box bg-red-500 text-white"></div>

    <!-- External Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    
    <script>
        /* =============================================================================
           APPLICATION CONFIGURATION
           ============================================================================= */
        
        const CONFIG = {
            LOCAL_STORAGE_KEY: 'pdfTaggerTags',
            SCALE_FACTOR: 1.1,
            CONTENT_TAGS: [
                'hebrew printed', 'hebrew paper clippings', 'hebrew handwritten',
                'non-hebrew printed', 'non-hebrew paper clippings',
                'image', 'undefined', 'mixed'
            ]
        };

        /* =============================================================================
           APPLICATION STATE
           ============================================================================= */
        
        const state = {
            pdfDoc: null,
            pdfBytes: null,
            currentPage: 1,
            pageTags: {},
            lastManualTag: null,
            pdfFilename: 'pdf_classifications',
            
            // Zoom and Pan state
            currentScale: 1.0,
            isDragging: false,
            lastX: 0,
            lastY: 0,
            translateX: 0,
            translateY: 0
        };

        /* =============================================================================
           DOM ELEMENTS
           ============================================================================= */
        
        const elements = {
            canvas: document.getElementById('pdf-canvas'),
            currentPageDisplay: document.getElementById('current-page-display'),
            totalPagesDisplay: document.getElementById('total-pages-display'),
            currentPageTagDisplay: document.getElementById('current-page-tag'),
            tagHistoryContainer: document.getElementById('tag-history'),
            loadingIndicator: document.getElementById('loading-indicator'),
            pdfFileInput: document.getElementById('pdf-file-input'),
            tagsFileInput: document.getElementById('tags-file-input'),
            exportButton: document.getElementById('export-button'),
            messageBox: document.getElementById('message-box'),
            pageJumpInput: document.getElementById('page-jump-input'),
            pdfViewerContainer: document.getElementById('pdf-viewer-container'),
            emptyMessage: document.getElementById('empty-message')
        };

        const ctx = elements.canvas.getContext('2d');

        /* =============================================================================
           UTILITY FUNCTIONS
           ============================================================================= */
        
        function showMessage(message, type = 'error') {
            elements.messageBox.textContent = message;
            elements.messageBox.className = `message-box show ${type === 'error' ? 'bg-red-500' : 'bg-green-500'} text-white`;
            setTimeout(() => {
                elements.messageBox.classList.remove('show');
            }, 3000);
        }

        function saveTagsToLocalStorage() {
            try {
                localStorage.setItem(CONFIG.LOCAL_STORAGE_KEY, JSON.stringify(state.pageTags));
            } catch (e) {
                console.error('Error saving to local storage:', e);
                showMessage('Could not save progress. Browser storage limit reached.');
            }
        }

        function initializePageTags(pageNum) {
            if (!state.pageTags[pageNum]) {
                state.pageTags[pageNum] = {
                    tags: [],
                    rotation: 0
                };
            }
        }

        /* =============================================================================
           PDF RENDERING FUNCTIONS
           ============================================================================= */
        
        async function renderPage(pageNum) {
            if (state.pdfDoc === null) return;
            elements.loadingIndicator.style.display = 'block';

            try {
                if (pageNum < 1 || pageNum > state.pdfDoc.numPages) {
                    showMessage('Invalid page number.', 'error');
                    return;
                }
                
                state.currentPage = pageNum;
                initializePageTags(state.currentPage);
                const rotation = state.pageTags[state.currentPage].rotation;
                const page = await state.pdfDoc.getPage(state.currentPage);
                
                // Calculate optimal scale if not zoomed
                if (state.currentScale === 1.0) {
                    const viewportAt1 = page.getViewport({ scale: 1, rotation });
                    const containerWidth = elements.pdfViewerContainer.clientWidth;
                    const containerHeight = elements.pdfViewerContainer.clientHeight;
                    const fitScale = Math.min(containerWidth / viewportAt1.width, containerHeight / viewportAt1.height);
                    state.currentScale = fitScale;
                }
                
                // Render page
                const viewport = page.getViewport({ scale: state.currentScale, rotation });
                elements.canvas.width = viewport.width;
                elements.canvas.height = viewport.height;
                const renderContext = { canvasContext: ctx, viewport };
                await page.render(renderContext).promise;

                // Update canvas transform for panning
                elements.canvas.style.transform = `translate(${state.translateX}px, ${state.translateY}px)`;
                
                // Update UI
                updatePageDisplay();

            } catch (error) {
                console.error('Error rendering page:', error);
                showMessage('Failed to render page. Please try again.');
            } finally {
                elements.loadingIndicator.style.display = 'none';
            }
        }

        function updatePageDisplay() {
            elements.currentPageDisplay.textContent = state.currentPage;
            const currentTags = state.pageTags[state.currentPage].tags;
            const rotation = state.pageTags[state.currentPage].rotation;
            const rotationTag = rotation === 0 ? '' : ` (Rotated ${rotation}°)`;
            elements.currentPageTagDisplay.textContent = (currentTags.length > 0)
                ? currentTags.join(', ') + rotationTag
                : 'No tag assigned' + rotationTag;
        }

        /* =============================================================================
           PDF LOADING FUNCTIONS
           ============================================================================= */
        
        async function loadPDF(source) {
            console.log('Loading PDF...', source instanceof File ? source.name : source);
            
            elements.loadingIndicator.style.display = 'block';
            elements.emptyMessage.style.display = 'none';
            elements.pdfViewerContainer.classList.remove('no-pdf');
            
            // Reset state
            state.currentPage = 1;
            state.lastManualTag = null;
            state.pageTags = {};
            state.currentScale = 1.0;
            state.translateX = 0;
            state.translateY = 0;
            
            elements.tagHistoryContainer.innerHTML = '';
            elements.currentPageTagDisplay.textContent = 'No tag assigned';
            localStorage.removeItem(CONFIG.LOCAL_STORAGE_KEY);

            try {
                let pdfData;
                if (source instanceof File) {
                    console.log('Reading file as array buffer...');
                    pdfData = await source.arrayBuffer();
                    console.log('File read successfully, size:', pdfData.byteLength);
                } else {
                    throw new Error("Invalid file type.");
                }

                state.pdfBytes = pdfData;
                console.log('Loading PDF document...');
                state.pdfDoc = await pdfjsLib.getDocument({ data: pdfData }).promise;
                console.log('PDF loaded successfully, pages:', state.pdfDoc.numPages);
                
                elements.totalPagesDisplay.textContent = state.pdfDoc.numPages;

                await renderPage(state.currentPage);
                console.log('First page rendered');
                
            } catch (error) {
                console.error('Error loading PDF:', error);
                showMessage('Failed to load PDF: ' + error.message);
                elements.emptyMessage.style.display = 'block';
                elements.pdfViewerContainer.classList.add('no-pdf');
            } finally {
                elements.loadingIndicator.style.display = 'none';
            }
        }

        /* =============================================================================
           TAGGING FUNCTIONS
           ============================================================================= */
        
        function updateTag(tag, isCarrying) {
            initializePageTags(state.currentPage);
            
            // Handle mutually exclusive content tags
            if (CONFIG.CONTENT_TAGS.includes(tag)) {
                state.pageTags[state.currentPage].tags = state.pageTags[state.currentPage].tags.filter(
                    existingTag => !CONFIG.CONTENT_TAGS.includes(existingTag)
                );
            }

            if (!state.pageTags[state.currentPage].tags.includes(tag)) {
                state.pageTags[state.currentPage].tags.push(tag);
            }
            
            // Handle auto-tagging
            if (isCarrying) {
                state.lastManualTag = tag;
            } else {
                if (tag !== 'redundant') {
                    state.lastManualTag = null;
                }
            }
            
            saveTagsToLocalStorage();
            updateTagHistory();
            renderPage(state.currentPage);
        }

        function updateTagHistory() {
            elements.tagHistoryContainer.innerHTML = '';
            const historyLimit = 10;
            const pages = Object.keys(state.pageTags).map(Number).sort((a, b) => b - a);
            const historyPages = pages.slice(0, historyLimit);

            historyPages.forEach(page => {
                const tags = state.pageTags[page].tags;
                const rotation = state.pageTags[page].rotation;
                const rotationText = rotation === 0 ? '' : ` (Rotated ${rotation}°)`;
                const historyItem = document.createElement('div');
                historyItem.className = 'flex justify-between items-center bg-gray-100 p-2 rounded-lg';
                historyItem.innerHTML = `<span class="font-semibold text-gray-700">Page ${page}:</span> <span class="text-blue-600 font-medium">${tags.join(', ')}${rotationText}</span>`;
                elements.tagHistoryContainer.appendChild(historyItem);
            });
        }

        /* =============================================================================
           EXPORT FUNCTIONS
           ============================================================================= */
        
        async function exportRotatedAndCleanPdf() {
            if (!state.pdfBytes) {
                showMessage('No PDF loaded to export.');
                return;
            }

            try {
                const { PDFDocument, degrees } = window.PDFLib;
                if (!PDFDocument) {
                    throw new Error('PDF-lib library not loaded.');
                }
                
                const originalPdf = await PDFDocument.load(state.pdfBytes);
                const newPdf = await PDFDocument.create();

                for (let i = 0; i < originalPdf.getPageCount(); i++) {
                    const pageNum = i + 1;
                    initializePageTags(pageNum);

                    // Skip redundant pages
                    if (state.pageTags[pageNum].tags.includes('redundant')) {
                        continue;
                    }

                    const [page] = await newPdf.copyPages(originalPdf, [i]);
                    const rotation = state.pageTags[pageNum].rotation;
                    
                    if (rotation !== 0) {
                        page.setRotation(degrees(rotation));
                    }
                    
                    newPdf.addPage(page);
                }

                const modifiedPdfBytes = await newPdf.save();
                const blob = new Blob([modifiedPdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `${state.pdfFilename}_clean.pdf`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
            } catch (error) {
                console.error('Error exporting PDF:', error);
                throw new Error('Failed to export PDF.');
            }
        }

        function exportCleanTagsJson() {
            if (Object.keys(state.pageTags).length === 0) {
                showMessage('No pages have been tagged yet.');
                return;
            }

            const cleanTags = {};
            let newPageNumber = 1;
            
            for (let i = 1; i <= state.pdfDoc.numPages; i++) {
                const pageData = state.pageTags[i];
                if (pageData && !pageData.tags.includes('redundant')) {
                    cleanTags[newPageNumber] = {
                        tags: [...pageData.tags],
                        rotation: pageData.rotation
                    };
                    newPageNumber++;
                }
            }

            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(cleanTags, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", `${state.pdfFilename}_clean.json`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        async function handleCombinedExport() {
            elements.exportButton.disabled = true;
            elements.exportButton.classList.add('bg-blue-400');
            elements.exportButton.innerHTML = 'Exporting... <span class="spinner"></span>';

            try {
                exportCleanTagsJson();
                await exportRotatedAndCleanPdf();
                showMessage('Export complete. Both PDF and tags JSON have been downloaded.', 'success');
            } catch (error) {
                console.error('Combined export failed:', error);
                showMessage('Export failed. Please try again.', 'error');
            } finally {
                elements.exportButton.disabled = false;
                elements.exportButton.classList.remove('bg-blue-400');
                elements.exportButton.innerHTML = 'Export All <span class="spinner hidden"></span>';
            }
        }

        /* =============================================================================
           EVENT HANDLERS
           ============================================================================= */
        
        function handleKeydown(e) {
            if (state.pdfDoc === null) return;

            const key = e.key.toLowerCase();
            
            switch (key) {
                case 'arrowleft':
                    if (state.currentPage > 1) {
                        state.currentPage--;
                        renderPage(state.currentPage);
                    }
                    break;
                    
                case 'arrowright':
                    if (state.currentPage < state.pdfDoc.numPages) {
                        state.currentPage++;
                        // Auto-tag if page is empty
                        if (state.lastManualTag && (!state.pageTags[state.currentPage] || state.pageTags[state.currentPage].tags.length === 0)) {
                            initializePageTags(state.currentPage);
                            state.pageTags[state.currentPage].tags.push(state.lastManualTag);
                            saveTagsToLocalStorage();
                        }
                        renderPage(state.currentPage);
                    }
                    break;
                    
                case '1': updateTag('hebrew printed', true); break;
                case '2': updateTag('hebrew paper clippings', true); break;
                case '3': updateTag('hebrew handwritten', true); break;
                case '4': updateTag('non-hebrew printed', true); break;
                case '5': updateTag('non-hebrew paper clippings', true); break;
                case '6': updateTag('image', true); break;
                case '7': updateTag('undefined', true); break;
                case '8': updateTag('mixed', true); break;
                
                case 'n':
                    // New document starts
                    initializePageTags(state.currentPage);
                    state.pageTags[state.currentPage].tags = ['new document starts', 'hebrew printed'];
                    state.lastManualTag = 'hebrew printed';
                    saveTagsToLocalStorage();
                    updateTagHistory();
                    renderPage(state.currentPage);
                    break;
                    
                case 'r':
                    // Redundant page
                    initializePageTags(state.currentPage);
                    state.pageTags[state.currentPage].tags = ['redundant'];
                    state.lastManualTag = null;
                    saveTagsToLocalStorage();
                    updateTagHistory();
                    renderPage(state.currentPage);
                    break;
                    
                case 't':
                    // Rotate page
                    initializePageTags(state.currentPage);
                    state.pageTags[state.currentPage].rotation = (state.pageTags[state.currentPage].rotation + 90) % 360;
                    saveTagsToLocalStorage();
                    updateTagHistory();
                    renderPage(state.currentPage);
                    showMessage('Page rotated 90 degrees.', 'success');
                    break;
                    
                case 'c':
                    // Clear tags
                    state.pageTags[state.currentPage].tags = [];
                    state.lastManualTag = null;
                    saveTagsToLocalStorage();
                    renderPage(state.currentPage);
                    showMessage('Tags cleared from this page.', 'success');
                    break;
                    
                case 'l':
                    // Continue previous document
                    if (state.currentPage > 1 && state.pageTags[state.currentPage]) {
                        const newDocTagIndex = state.pageTags[state.currentPage].tags.indexOf('new document starts');
                        if (newDocTagIndex !== -1) {
                            state.pageTags[state.currentPage].tags.splice(newDocTagIndex, 1);
                        }
                        // Set auto-tagging to the last tag of the previous page
                        const prevPageTags = state.pageTags[state.currentPage - 1];
                        if (prevPageTags && prevPageTags.tags.length > 0) {
                            state.lastManualTag = prevPageTags.tags[prevPageTags.tags.length - 1];
                        } else {
                            state.lastManualTag = null;
                        }
                        saveTagsToLocalStorage();
                        renderPage(state.currentPage);
                        showMessage('Continuing previous document.', 'success');
                    } else {
                        showMessage('Cannot continue previous document. No tags on previous page or this is the first page.', 'error');
                    }
                    break;
            }
        }

        function handlePageJump(e) {
            if (e.key === 'Enter') {
                const pageNum = parseInt(elements.pageJumpInput.value, 10);
                if (state.pdfDoc && pageNum >= 1 && pageNum <= state.pdfDoc.numPages) {
                    renderPage(pageNum);
                    elements.pageJumpInput.value = '';
                } else {
                    showMessage('Please enter a valid page number.', 'error');
                }
            }
        }

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (file) {
                console.log('File selected:', file.name);
                state.pdfFilename = file.name.replace(/\.pdf$/, '');
                loadPDF(file);
            }
        }

        function handleTagsLoad(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const loadedTags = JSON.parse(e.target.result);
                        // Convert old format to new format if necessary
                        for (const page in loadedTags) {
                            if (Array.isArray(loadedTags[page])) {
                                loadedTags[page] = { tags: loadedTags[page], rotation: 0 };
                            } else if (typeof loadedTags[page] !== 'object' || !Array.isArray(loadedTags[page].tags)) {
                                console.warn('Invalid page data format, skipping:', loadedTags[page]);
                                delete loadedTags[page];
                            }
                        }
                        state.pageTags = loadedTags;
                        updateTagHistory();
                        renderPage(state.currentPage);
                        showMessage('Tags loaded successfully from file!', 'success');
                    } catch (error) {
                        console.error('Error parsing JSON file:', error);
                        showMessage('Failed to load tags. Invalid JSON format.', 'error');
                    }
                };
                reader.readAsText(file);
            }
        }

        /* =============================================================================
           CANVAS INTERACTION HANDLERS
           ============================================================================= */
        
        function handleMouseDown(e) {
            e.preventDefault();
            if (!state.pdfDoc) return;
            state.isDragging = true;
            state.lastX = e.clientX;
            state.lastY = e.clientY;
            elements.canvas.style.cursor = 'grabbing';
        }

        function handleMouseMove(e) {
            if (!state.isDragging || !state.pdfDoc) return;
            const dx = e.clientX - state.lastX;
            const dy = e.clientY - state.lastY;
            state.translateX += dx;
            state.translateY += dy;
            elements.canvas.style.transform = `translate(${state.translateX}px, ${state.translateY}px)`;
            state.lastX = e.clientX;
            state.lastY = e.clientY;
        }

        function handleMouseUp() {
            state.isDragging = false;
            elements.canvas.style.cursor = 'grab';
        }

        function handleWheel(e) {
            e.preventDefault();
            if (!state.pdfDoc) return;
            
            const oldScale = state.currentScale;
            state.currentScale = e.deltaY > 0 ? oldScale / CONFIG.SCALE_FACTOR : oldScale * CONFIG.SCALE_FACTOR;

            // Constrain scale
            state.currentScale = Math.max(0.1, Math.min(10.0, state.currentScale));

            // Calculate new position to zoom around mouse cursor
            const rect = elements.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const oldWidth = elements.canvas.width;
            const oldHeight = elements.canvas.height;

            const newWidth = oldWidth * (state.currentScale / oldScale);
            const newHeight = oldHeight * (state.currentScale / oldScale);

            state.translateX -= (mouseX / oldWidth) * (newWidth - oldWidth);
            state.translateY -= (mouseY / oldHeight) * (newHeight - oldHeight);
            
            renderPage(state.currentPage);
        }

        /* =============================================================================
           EVENT LISTENER REGISTRATION
           ============================================================================= */
        
        function initializeEventListeners() {
            // Keyboard events
            document.addEventListener('keydown', handleKeydown);
            
            // Page jump
            elements.pageJumpInput.addEventListener('keydown', handlePageJump);
            
            // File inputs
            elements.pdfFileInput.addEventListener('change', handleFileLoad);
            elements.tagsFileInput.addEventListener('change', handleTagsLoad);
            
            // Export button
            elements.exportButton.addEventListener('click', handleCombinedExport);
            
            // Canvas interactions
            elements.canvas.addEventListener('mousedown', handleMouseDown);
            elements.canvas.addEventListener('mousemove', handleMouseMove);
            elements.canvas.addEventListener('mouseup', handleMouseUp);
            elements.canvas.addEventListener('mouseleave', handleMouseUp);
            elements.canvas.addEventListener('wheel', handleWheel);
        }

        /* =============================================================================
           APPLICATION INITIALIZATION
           ============================================================================= */
        
        function initializeApp() {
            // Ensure PDF.js is loaded
            if (typeof pdfjsLib === 'undefined') {
                console.error('PDF.js library not loaded');
                showMessage('PDF.js library failed to load. Please refresh the page.', 'error');
                return;
            }
            
            // Set up PDF.js worker
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
            
            initializeEventListeners();
            console.log('PDF Document Classifier initialized successfully');
        }

        // Start the application when libraries are loaded
        function waitForLibraries() {
            if (typeof pdfjsLib !== 'undefined' && typeof PDFLib !== 'undefined') {
                initializeApp();
            } else {
                // Wait a bit more for libraries to load
                setTimeout(waitForLibraries, 100);
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', waitForLibraries);
        } else {
            waitForLibraries();
        }
    </script>
</body>
</html>
